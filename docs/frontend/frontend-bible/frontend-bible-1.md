---
sidebar_position: 1
---

# 프론트엔드 바이블 (1)

> [ 😃 Esoolgnah ](#-references-) 님의 중요도 정리 내용을 한 페이지에 담았습니다.

## [ 브라우저의 렌더링 원리 ]

> 브라우저가 화면에 나타나는 요소를 렌더링 할 때, 웹킷(Webkit)이나 게코(Gecko) 등과 같은 렌더링엔진 을 사용합니다.
> 렌더링 엔진이 HTML, CSS, Javascript로 렌더링할 때 CRP라는 프로세스를 사용하며 다음 단계들로 이루어집니다.

<br />

::::note 렌더링 순서

1. **HTML**를 파싱 후, **DOM**트리를 구축합니다.
2. **CSS**를 파싱 후, **CSSOM**트리를 구축합니다.
3. **Javascript**를 실행합니다.
   :::danger 주의!
   **HTML 중간에 스크립트가 있다면 HTML 파싱이 중단됩니다.**
   :::
4. **DOM과 CSSOM을 조합**하여 **렌더트리를 구축**합니다.
   :::danger 주의!
   **`display: none` 속성과 같이 화면에서 보이지도 않고 공간을 차지하지 않는 것은 렌더트리로 구축되지 않습니다.**
   :::
5. 뷰포트 기반으로 렌더트리의 각 노드가 가지는 정확한 위치와 크기를 계산합니다. _(Layout 단계)_
6. 계산한 위치/크기를 기반으로 화면에 그립니다. _(Paint 단계)_

::::

---

## [ Reflow와 Repaint가 실행되는 시점 ]

> **`Reflow란?`**
>
> 생성된 DOM 노드의 레이아웃 수치(너비, 높이, 위치 등) 변경 시 영향 받은 모든 노드의(자신, 자식, 부모, 조상(결국 모든 노드) ) 수치를 다시 계산하여(Recalculate), 렌더 트리를 재생성하는 과정을 Reflow 라고 합니다.

:::note

- **DOM 엘리먼트 추가, 제거 또는 변경**
- **CSS 스타일 추가, 제거 또는 변경**
- **CSS 스타일을 직접 변경**하거나, **클래스를 추가함으로써 레이아웃이 변경될 수 있습니다.** 엘리먼트의 길이를 변경하면, **DOM 트리에 있는 다른 노드에 영향을 줄 수 있습니다.**
- **CSS3 애니메이션과 트랜지션. 애니메이션의 모든 프레임에서 리플로우가 발생합니다.**
- **offsetWidth 와 offsetHeight 의 사용. offsetWidth 와 offsetHeight 속성을 읽으면, 초기 리플로우가 트리거되어 수치가 계산됩니다.**
- **유저 행동. 유저 인터랙션으로 발생하는 hover 효과, 필드에 텍스트 입력, 창 크기 조정, 글꼴 크기 변경, 스타일시트 또는 글꼴 전환등을 활성화하여 리플로우를 트리거할 수 있습니다.**

:::

<br />

> **`Repaint란?`**
>
> **Reflow** 과정이 끝난 후 재 생성된 렌더 트리를 다시 그리게 되는데 이 과정을 **Repaint** 라고 합니다.

:::note

- 가시성이 변경되는 순간 **(opacity, background-color, visibility, outline)**
- **Reflow** 가 실행된 순간 뒤에 실행됩니다.

:::

---

## [ 주소창에 google.com을 입력하면 일어나는 일 ]

::::note

1. 사용자가 웹 브라우저를 통해 google.com 을 입력하면 URL 주소 중 도메인 네임 부분을 DNS 서버에서 검색합니다.
2. DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달합니다.
3. 브라우저는 HTTP 프로토콜을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 TCP/IP 프로토콜을 사용하여 서버로 전송됩니다.
4. 서버는 response 메시지를 생성하여 다시 브라우저에게 데이터를 전송합니다.
5. 브라우저는 response를 받아 파싱하여 화면에 렌더링합니다.

:::info 용어 정리

- **DNS**

  도메인 이름 시스템(DNS)은 사람이 읽을 수 있는 도메인 이름(예: www.amazon.com )을 머신이 읽을 수 있는 IP 주소(예: 192.0.2.44)로 변환합니다. 모든 통신에는 주소가 필요합니다. 출발지와 도착지의 주소를 알아야 통신을 할 수 있습니다. 우리는 이 주소를 IP라고 부릅니다. IP 주소로 변환하는 과정에 개입하는 것이 DNS 입니다.

- **URL**

  URL(Uniform Resource Locator)은 통합 자원 지시자로 인터넷의 리소스를 가리키는 표준 명칭으로 서버의 자원을 요청할 때 사용됩니다. URL을 통해 인터넷 상의 모든 리소스를 요청할 수 있으며, HTTP, FTP 등의 자원 요청도 가능합니다.

- **HTTP**

  HTTP(HyperText Transfer Protocol)은 TCP 기반의 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜입니다. HTTP는 Text Protocol로 사람이 쉽게 읽고 쓸 수 있습니다. 프로토콜 설계상 클라이언트가 요청을 보내면 반드시 응답을 받아야 합니다. 응답을 받아야 다음 request를 보낼 수 있습니다.

- **프로토콜**

  프로토콜은 통신하기 위한 약속들을 기술적으로 잘 정의해 둔 것입니다. 데이터를 송수신하는 순서와 내용을 결정합니다. HTTP, TCP/IP, UDP 모두 프로토콜입니다.

- **TCP**

  TCP (전송 제어 프로토콜)은 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜입니다. TCP는 데이터 전송을 제어하고 데이터를 어떻게 보낼 지, 어떻게 맞출 지 정합니다. 또한 데이터와 패킷이 보내진 순서대로 전달하는 것을 보장해줍니다.신뢰성과 연결성을 책임지기 위한 프로토콜이 TCP입니다. 호스트와 호스트간의 데이터 전송은 IP(인터넷 계층 프로토콜)에 의지하면서 동시에 신뢰성 있는 전송에 대해서는 TCP가 책임지는 구조입니다.

- **IP**

  IP (Internet Protocol)은 비신뢰성, 비연결지향 데이터그램 프로토콜로 패킷을 받아서 주소를 해석하고 경로를 결정하여 다음 호스트로 전송하는 역할을 합니다.

- **Response**

  HTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식입니다. 메시지 타입은 두 가지가 있습니다. 요청(request)은 클라이언트가 서버로 전달해서 서버의 액션이 일어나게끔 하는 메시지고, 응답(response)은 요청에 대한 서버의 답변입니다.

- **파싱**

  파싱은 하나의 프로그램을 런타임 환경(예를 들면, 브라우저 내 자바스크립트 엔진)이 실제로 실행할 수 있는 내부 포맷으로 분석하고 변환하는 것을 의미합니다. 즉, 파싱은 문서의 내용을 토큰(token)으로 분석하고, 문법적 의미와 구조를 반영한 파스 트리(parse tree)를 생성하는 과정입니다.

:::

::::

---

## [ 호이스팅(hoisting)이란? ]

> 호이스팅이란 **`"끌어올린다"`** 라는 뜻으로 변수 및 함수 선언문이 스코프 내의 최상단으로 끌어올려지는 현상을 말합니다. 여기서 주의할 점은 **`"선언문"`** 이라는 것이며 **`"대입문"`**은 끌어올려지지 않습니다.

> _실행 컨텍스트 생성 시 렉시컬 스코프 내의 선언이 끌어올려 지는 게 호이스팅입니다._

:::::note

```js
console.log(a);
var a = 2;
```

```js
undefined;
```

::::info

> **컴파일러는 자바스크립트 엔진이 인터프리팅을 하기 전에 컴파일을 하는데 이 때, `var a = 2; 를 2개의 구문으로 봅니다.`**

    var a
    a = 2

> **var a 는 변수 선언문으로 컴파일을 할 때 처리**하고, **a = 2 는 실행할 때까지 내버려둡니다.** 따라서, 변수 a는 호이스팅 되고 콘솔에는 **`undefined`**가 출력됩니다.

:::danger let, const

- `var는` 선언, 초기화가 동시에 이루어지기 때문에 `undefined를 출력`
- `let, const는` 선언단계만 호이스팅 되기 때문에 `Reference Error를 출력`

:::

<br />

> **함수 선언문의 경우도 호이스팅이 됩니다.**

```js
func();
function func() {
  console.log("함수 호이스팅");
}
```

- 변수를 선언하는 것(const,let 등)처럼 함수 선언은 function으로 시작합니다.
- 선언 된 함수는 나중 사용을 위해 저장되며 call 될 때 실행됩니다.

<br />

:::danger **함수표현식**

> **함수 호이스팅에서 함수 표현식은 호이스팅 되지 않습니다.**

```js
var x = function (a, b) {
  return a * b;
};
```

- 자바스크립트 함수는 표현식을 사용하여 정의 될 수 있으며, 함수 표현식은 변수로 저장될 수 있습니다.
- 함수 표현식이 변수에 저장되면, 변수는 함수처럼 사용 가능해집니다. 변수에 저장된 함수는 함수명이 필요 없으며, 변수 이름을 통하여 호출됩니다.

:::

::::

:::::

## [ References ]

> [Frontend-Interview-Questions](https://github.com/Esoolgnah/Frontend-Interview-Questions)
